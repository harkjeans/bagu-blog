## 计算机网络

### 1 介绍下OSI模型和TCP/IP模型的区别

关于OSI模型和TCP/IP模型，首先最核心的区别是：OSI是一个理论上的**参考模型**而TCP/IP是一个实践中运行的**协议模型**。

具体来讲他们的区别主要有以下几点：

首先是出生和目的不同，OSI模型由ISO提出的，是**“模型先行”**。它先设计一个分层框架来让大家遵守，是一个**理想化标准**。而TCP/IP模型源于美国国防部的APARNET项目，是**“协议先行”**。它是从实际应用中先有了TCP/IP这些协议再被总结为模型，是**互联网的事实标准**。

其次是结构层次不同，OSI有**7层**，从下至上分别为**物理层、数据链路层、网络层、传输层、会话层、表示层和应用层**。

- 物理层是最底层，它负责**在物理媒介上传输原始的比特流**，网线、光纤、集线器工作在这一层。
- 数据链路层负责**在同一个局域网内节点到节点的可靠传输**，它将比特流组装成“帧”，帧头包含MAC地址来寻址，帧尾包含校验码进行差错检测，交换机、网卡驱动工作在这一层。
- 网络层负责**在不同网络之间进行数据路由**，即选择最佳路径将数据包从源主机送到目标主机，IP协议、路由器是这一层的核心，其中**IP协议使用IP地址来标识主机和网络，并进行逻辑地址寻址**。
- 传输层负责**端到端的数据传输**，借助不同协议提供差异化服务，主要的传输层协议有TCP和UDP，**TCP是面向连接的、可靠的传输协议**，确保数据的正确性和完整性，**TCP的三次握手和四次挥手就是在这层实现的，**而**UDP则是无连接的、高效的传输协议**，适用于不要求可靠性的传输，如实时音频和视频流。
- 会话层负责**建立、管理和终止两个应用程序之间的会话**。
- 表示层充当翻译官的角色，负责数**据的格式转换、加密解密、压缩解压缩**。
- 应用层最靠近用户的一层，**为应用程序提供网络访问的接口，实现具体的网络服务**，如电子邮件（SMTP）、网页浏览（HTTP）、文件传输（FTP）等。

TCP/IP有4层，从下至上分别为网络接口层（**对应OSI的物理层和数据链路层**）、网络层、传输层和应用层（**整合了OSI模型中会话、表示、应用三层的功能**）。



### 2 从输入URL到页面展示发生了什么？

从输入URL到页面展示这个过程可以概括为：**URL解析 -> DNS域名解析 -> TCP握手 -> HTTP请求 -> 服务器处理响应 -> 浏览器解析渲染 -> TCP挥手**。

1. **URL解析：** 浏览器首先会解析输入的URL，比如 `https://www.example.com/index.html`。它会分析出协议（`https`）、主机名（`www.example.com`）、端口（`https`默认443）、路径（`/index.html`）等信息。

2. **DNS域名解析：** 浏览器需要知道目标服务器的IP地址才能通信。这个过程就是域名解析。
   - 浏览器会先检查**本地缓存**（浏览器缓存、操作系统缓存）。
   - 如果缓存没有，会向**本地配置的DNS服务器**（通常是路由器或运营商提供的）发起查询。
   - 查询是一个**递归过程**，可能经过根域名服务器、顶级域名（.com）服务器、权威域名服务器，最终获得IP地址。

3. **TCP握手：**拿到IP地址后，浏览器要通过**传输层的TCP协议**与服务器建立一个可靠的连接。**核心过程就是三次握手：**
   - 浏览器向服务器发送一个`SYN`（同步）包，表示请求建立连接。
   - 服务器收到后，回复一个`SYN-ACK`（同步确认）包，表示同意。
   - 浏览器再回复一个`ACK`包，握手完成。此时，TCP连接就建立好了。

​	**如果是HTTPS协议，还需要额外的TLS握手**，用于协商加密密钥、验证服务器证书等，确保通信安全。

4. **HTTP请求：**连接建立后，浏览器会构造一个**HTTP请求报文**，并通过这个TCP连接发送给服务器。请求报文主要包括：
   - **请求行：** 包含方法（GET/POST）、路径、HTTP版本。
   - **请求头：** 包含浏览器信息（User-Agent）、接受的数据类型（Accept）、Cookie等重要信息。
   - **请求体：** 如果是POST请求，会包含提交的表单数据等。

5. **服务器处理响应：**服务器接收到请求后，会根据路径和参数进行处理（比如调用后端应用、查询数据库）。处理完成后，服务器会返回一个**HTTP响应报文**。响应报文主要包括：
   - **状态行：** 包含状态码（如200成功、404未找到）。
   - **响应头：** 包含内容类型（Content-Type）、内容长度、设置Cookie等信息。
   - **响应体：** 即我们真正请求的数据，通常是HTML文档。

**浏览器解析渲染和TCP挥手是异步进行的，但核心在于页面的主要解析和渲染过程发生在TCP连接关闭之前。**

6. **浏览器解析渲染：**

   - **解析HTML，构建DOM树：** 浏览器从上到下解析HTML代码，将标签转换为树状结构的**DOM（文档对象模型）**。
   - **解析CSS，构建CSSOM树：** 同时，浏览器会解析CSS（包括外部样式表、内联样式），生成**CSSOM（CSS对象模型）**，它决定了每个DOM节点的样式。
   - **合并成渲染树：** 将DOM树和CSSOM树合并，生成一棵**渲染树**，它只包含需要显示在页面上的元素。
   - **布局：** 根据渲染树，计算每个节点在屏幕上的确切位置和大小。
   - **绘制：** 遍历渲染树，调用操作系统API，将每个节点绘制到屏幕上（像素化）。
   - **合成：** 现代浏览器有合成层机制，会将页面分成多个图层，分别绘制，最后再合成一个完整的页面，这样效率更高。

   **注：**HTML解析过程一旦遇到 `<script>` 标签，会**暂停DOM的构建**，先去下载（如果是外部脚本）和执行JavaScript。因为JS可能会修改DOM或CSSOM。所以通常建议将`<script>`标签放在body底部，或者使用`async`/`defer`属性来避免阻塞解析。

7. **TCP挥手：**当页面数据传输完成后，TCP连接会通过**四次挥手**的过程被安全地关闭。

   - 客户端发送一个 `FIN` 报文，并进入 `FIN_WAIT_1` 状态。
   - 服务器收到 `FIN` 后，立即回复一个 `ACK` 确认报文。此时，服务器可能还有数据要发送，进入 `CLOSE_WAIT` 状态。客户端收到 `ACK` 后进入 `FIN_WAIT_2` 状态。
   -  当服务器处理完所有剩余数据后，也发送一个 `FIN` 报文给客户端，然后进入 `LAST_ACK` 状态。
   -  客户端收到 `FIN` 后，发送最后一个 `ACK` 确认报文，并进入 `TIME_WAIT` 状态，等待一段时间（2MSL）后最终关闭。服务器收到这个 `ACK` 后便立即关闭连接。



### 3 HTTP请求报文和响应报文是怎样的，有哪些常见的字段？

HTTP报文是HTTP协议中用于在客户端和服务器之间传输数据的基本单位，它分为请求报文和响应报文两种。它们的结构类似，都包含三个部分：**起始行、头部字段和消息体**。

首先，是客户端发送给服务器的**请求报文**

1. **请求行**
   - 这是报文的第一行，包含了三个核心信息：
     - **方法：** 表示请求的目的，如 `GET`（获取资源）、`POST`（提交数据）、`PUT`（更新资源）、`DELETE`（删除资源）。
     - **请求目标：** 通常是URL的路径和查询参数，例如 `/index.html?name=value`。
     - **HTTP版本：** 如 `HTTP/1.1` 或 `HTTP/2`。
2. **请求头**
   - 紧接着请求行之后，每一行都是一个 `键: 值` 对，用于向服务器传递附加信息。
   - **常见重要字段包括：**
     - `Host`：**（必需）** 指定请求的服务器的域名和端口号。
     - `User-Agent`：告知服务器客户端的类型（如浏览器型号、操作系统）。
     - `Accept`：声明客户端可以处理的内容类型，如 `text/html, application/json`。
     - `Content-Type`：**（在POST/PUT等有体的请求中非常重要）** 声明请求体的数据类型，如 `application/json`、`application/x-www-form-urlencoded`。
     - `Cookie`：将本地存储的Cookie信息发送给服务器，用于身份验证等。
     - `Authorization`：用于携带身份验证凭证，如Bearer Token。
3. **请求体**
   - 在头部之后，用一个空行隔开，后面就是可选的请求体。
   - **GET请求通常没有请求体**，而 **POST、PUT等方法** 会使用请求体来发送数据，比如表单数据或JSON数据。

**举例：**

```json
GET /api/users/123 HTTP/1.1
Host: api.example.com
User-Agent: Mozilla/5.0...
Accept: application/json
Cookie: sessionId=abc123
```

*(这是一个GET请求，所以没有请求体)*

服务器收到请求后，会返回一个**响应报文**。

1. **状态行**
   - 响应的第一行，也包含三个部分：
     - **HTTP版本：** 如 `HTTP/1.1 200 OK`。
     - **状态码：** 一个三位数字，清晰表示请求的结果。这是最关键的信息。
     - **原因短语：** 对状态码的简短文字描述，如 `OK`。
2. **响应头**
   - 同样由 `键: 值` 对组成，描述了服务器的信息和返回的资源信息。
   - **常见重要字段包括：**
     - `Status Code`：状态码本身，如 `200`（成功）、`404`（未找到）、`500`（服务器内部错误）、`301`（永久重定向）。
     - `Content-Type`：**（非常重要）** 声明响应体的数据类型，如 `text/html; charset=UTF-8`、`application/json`。浏览器据此决定如何解析内容。
     - `Content-Length`：响应体的长度（字节）。
     - `Set-Cookie`：服务器要求客户端设置Cookie。
     - `Cache-Control`：指示客户端如何缓存响应资源，对性能优化至关重要，如 `max-age=3600`。
     - `Location`：在重定向（状态码3xx）时，指定新的URL地址。
3. **响应体**
   - 空行之后，就是服务器返回的实际数据，比如HTML文档、JSON数据或图片文件等。

**举例：**

```json
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 56
Cache-Control: max-age=3600

{"id": 123, "name": "张三", "email": "zhangsan@example.com"}
```



### 4 HTTP有哪些请求方式？

HTTP协议定义了一组请求方法，也称为HTTP动词，用来表明要对目标资源执行的操作。**最核心和常见的是GET和POST**，但还有其他一些重要的方法。

1. **GET**
   - **语义：** **获取**资源。它应该是幂等的、安全的，意味着多次执行相同的GET请求，效果是一样的，且不会修改服务器数据。
   - **特点：** 请求参数直接附加在URL后面（查询字符串），有长度限制（因浏览器和服务器而异），可以被缓存、收藏为书签。
   - **场景：** 请求页面、搜索查询、获取数据等。
2. **POST**
   - **语义：** **提交**数据，用于创建新资源或触发一个处理数据的操作。它既不是安全的也不是幂等的。
   - **特点：** 数据放在请求体中，更适合传输敏感或大量数据（如图片、表单提交）。
   - **场景：** 用户登录、提交表单、上传文件。
3. **PUT**
   - **语义：** **更新**整个资源。客户端提供更新后的完整资源信息。它是幂等的。
   - **场景：** 更新用户的所有个人信息。
4. **DELETE**
   - **语义：** **删除**指定的资源。它也是幂等的。
   - **场景：** 删除一篇文章。
5. **PATCH**
   - **语义：** **部分更新**资源。客户端只提供需要修改的字段，而不是整个资源。它通常不是幂等的。
   - **场景：** 只更新用户的手机号码。
6. **HEAD**
   - **语义：** 与GET类似，但服务器**只返回响应头，不返回响应体**。用于获取资源的元信息（如大小、类型），检查资源是否存在或是否被修改。
   - **场景：** 在下载大文件前检查其大小或最后修改时间。



### 5 GET请求和POST请求的区别

GET和POST是HTTP协议中最基础的两种请求方法，它们的区别可以从**语义、用法、安全性、技术实现**等多个维度来理解。最核心的区别在于它们的**设计语义**不同。

- **GET** 的语义是 **“获取”** 数据。它用于从服务器检索资源，不应该对服务器状态产生任何副作用。它是 **“安全”** 且 **“幂等”** 的。
  - **安全**：意味着操作只是读取，不会修改数据。
  - **幂等**：意味着多次执行相同的GET请求，得到的结果都是一样的。
- **POST** 的语义是 **“提交/创建”** 数据。它用于向服务器提交数据，通常会改变服务器上的状态（如新建一个订单、更新数据库）。它既 **不是安全** 的，也 **不是幂等** 的。

**“幂等性”举例：** 比如我用GET请求查询用户信息，无论执行多少次，结果都一样。但如果我用POST请求创建一个新用户，执行两次就会创建两个用户，所以它不是幂等的。

基于上述语义，它们在具体实现上产生了差异。

| 特性          | GET                                                  | POST                                                         |
| :------------ | :--------------------------------------------------- | :----------------------------------------------------------- |
| **参数位置**  | 附在**URL**之后，作为**查询字符串**                  | 放在**请求体**中                                             |
| **数据大小**  | 受**URL长度限制**（浏览器和服务器不同，通常2KB-8KB） | **理论上无限制**，实际受服务器配置约束                       |
| **数据类型**  | 只允许ASCII字符                                      | 支持二进制数据（如文件上传）                                 |
| **安全性**    | **差**。参数直接暴露在URL、浏览器历史、服务器日志中  | **相对较好**。参数在请求体内，不直接可见（但仍是明文，HTTPS才是关键） |
| **缓存**      | **可被缓存**，可被收藏为书签                         | **默认不可缓存**，不可被收藏为书签                           |
| **后退/刷新** | 无害（因为是幂等的）                                 | 浏览器会提示“是否重新提交表单”（因为不是幂等的）             |
